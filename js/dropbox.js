// Generated by CoffeeScript 1.3.3
(function() {
  var Dropbox, DropboxApiError, DropboxAuthDriver, DropboxClient, DropboxCopyReference, DropboxNodeServerDriver, DropboxOauth, DropboxPopupDriver, DropboxPublicUrl, DropboxPullChange, DropboxPulledChanges, DropboxRedirectDriver, DropboxStat, DropboxUserInfo, DropboxXhr, DropboxXhrCanSendForms, DropboxXhrIeMode, DropboxXhrRequest, add32, arrayToBase64, atob, base64HmacSha1, base64Sha1, btoa, crypto, dropboxEncodeKey, hmacSha1, rotateLeft32, sha1, stringToArray, _base64Digits,
    __hasProp = {}.hasOwnProperty;

  DropboxApiError = (function() {

    function DropboxApiError(xhr, method, url) {
      var text;
      this.method = method;
      this.url = url;
      this.status = xhr.status;
      if (xhr.responseType) {
        text = xhr.response || xhr.responseText;
      } else {
        text = xhr.responseText;
      }
      if (text) {
        try {
          this.responseText = text.toString();
          this.response = JSON.parse(text);
        } catch (e) {
          this.response = null;
        }
      } else {
        this.responseText = '(no response)';
        this.response = null;
      }
    }

    DropboxApiError.prototype.toString = function() {
      return "Dropbox API error " + this.status + " from " + this.method + " " + this.url + " :: " + this.responseText;
    };

    DropboxApiError.prototype.inspect = function() {
      return this.toString();
    };

    return DropboxApiError;

  })();

  if (typeof window !== "undefined" && window !== null) {
    atob = window.atob;
    btoa = window.btoa;
  } else {
    atob = function(arg) {
      var buffer, i;
      buffer = new Buffer(arg, 'base64');
      return ((function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = buffer.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(String.fromCharCode(buffer[i]));
        }
        return _results;
      })()).join('');
    };
    btoa = function(arg) {
      var buffer, i;
      buffer = new Buffer((function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = arg.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(arg.charCodeAt(i));
        }
        return _results;
      })());
      return buffer.toString('base64');
    };
  }

  DropboxClient = (function() {

    function DropboxClient(options) {
      this.sandbox = options.sandbox || false;
      this.apiServer = options.server || this.defaultApiServer();
      this.authServer = options.authServer || this.defaultAuthServer();
      this.fileServer = options.fileServer || this.defaultFileServer();
      this.oauth = new DropboxOauth(options);
      this.uid = null;
      this.authState = null;
      this.authError = null;
      this._credentials = null;
      this.setCredentials(options);
      this.setupUrls();
    }

    DropboxClient.prototype.authDriver = function(driver) {
      this.authDriver = driver;
      return this;
    };

    DropboxClient.prototype.dropboxUid = function() {
      return this.uid;
    };

    DropboxClient.prototype.credentials = function(newCredentials) {
      if (!this._credentials) {
        this.computeCredentials();
      }
      return this._credentials;
    };

    DropboxClient.prototype.authenticate = function(callback) {
      var oldAuthState, _fsmStep,
        _this = this;
      oldAuthState = null;
      _fsmStep = function() {
        var authUrl;
        if (oldAuthState !== _this.authState) {
          oldAuthState = _this.authState;
          if (_this.authDriver.onAuthStateChange) {
            return _this.authDriver.onAuthStateChange(_this, _fsmStep);
          }
        }
        switch (_this.authState) {
          case DropboxClient.RESET:
            return _this.requestToken(function(error, data) {
              var token, tokenSecret;
              if (error) {
                _this.authError = error;
                _this.authState = DropboxClient.ERROR;
              } else {
                token = data.oauth_token;
                tokenSecret = data.oauth_token_secret;
                _this.oauth.setToken(token, tokenSecret);
                _this.authState = DropboxClient.REQUEST;
              }
              _this._credentials = null;
              return _fsmStep();
            });
          case DropboxClient.REQUEST:
            authUrl = _this.authorizeUrl(_this.oauth.token);
            return _this.authDriver.doAuthorize(authUrl, _this.oauth.token, _this.oauth.tokenSecret, function() {
              _this.authState = DropboxClient.AUTHORIZED;
              _this._credentials = null;
              return _fsmStep();
            });
          case DropboxClient.AUTHORIZED:
            return _this.getAccessToken(function(error, data) {
              if (error) {
                _this.authError = error;
                _this.authState = DropboxClient.ERROR;
              } else {
                _this.oauth.setToken(data.oauth_token, data.oauth_token_secret);
                _this.uid = data.uid;
                _this.authState = DropboxClient.DONE;
              }
              _this._credentials = null;
              return _fsmStep();
            });
          case DropboxClient.DONE:
            return callback(null, _this);
          case Dropbox.SIGNED_OFF:
            _this.reset();
            return _fsmStep();
          case DropboxClient.ERROR:
            return callback(_this.authError);
        }
      };
      _fsmStep();
      return this;
    };

    DropboxClient.prototype.signOut = function(callback) {
      var params, url,
        _this = this;
      url = this.urls.signOut;
      params = this.oauth.addAuthParams('POST', url, {});
      return DropboxXhr.request('POST', url, params, null, function(error) {
        if (error) {
          return callback(error);
        }
        _this.reset();
        _this.authState = DropboxClient.SIGNED_OFF;
        if (_this.authDriver.onAuthStateChange) {
          return _this.authDriver.onAuthStateChange(_this, function() {
            return callback(error);
          });
        } else {
          return callback(error);
        }
      });
    };

    DropboxClient.prototype.signOff = function(callback) {
      return this.signOut(callback);
    };

    DropboxClient.prototype.getUserInfo = function(callback) {
      var params, url;
      url = this.urls.accountInfo;
      params = this.oauth.addAuthParams('GET', url, {});
      return DropboxXhr.request('GET', url, params, null, function(error, userData) {
        return callback(error, DropboxUserInfo.parse(userData), userData);
      });
    };

    DropboxClient.prototype.readFile = function(path, options, callback) {
      var params, responseType, url;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      url = "" + this.urls.getFile + "/" + (this.urlEncodePath(path));
      params = {};
      responseType = null;
      if (options) {
        if (options.versionTag) {
          params.rev = options.versionTag;
        } else if (options.rev) {
          params.rev = options.rev;
        }
        if (options.blob) {
          responseType = 'blob';
        }
        if (options.binary) {
          responseType = 'b';
        }
      }
      this.oauth.addAuthParams('GET', url, params);
      return DropboxXhr.request2('GET', url, params, null, null, responseType, function(error, data, metadata) {
        return callback(error, data, DropboxStat.parse(metadata));
      });
    };

    DropboxClient.prototype.writeFile = function(path, data, options, callback) {
      var useForm;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      useForm = DropboxXhr.canSendForms && typeof data === 'object';
      if (useForm) {
        return this.writeFileUsingForm(path, data, options, callback);
      } else {
        return this.writeFileUsingPut(path, data, options, callback);
      }
    };

    DropboxClient.prototype.writeFileUsingForm = function(path, data, options, callback) {
      var fileField, fileName, params, slashIndex, url;
      slashIndex = path.lastIndexOf('/');
      if (slashIndex === -1) {
        fileName = path;
        path = '';
      } else {
        fileName = path.substring(slashIndex);
        path = path.substring(0, slashIndex);
      }
      url = "" + this.urls.postFile + "/" + (this.urlEncodePath(path));
      params = {
        file: fileName
      };
      if (options) {
        if (options.noOverwrite) {
          params.overwrite = 'false';
        }
        if (options.lastVersionTag) {
          params.parent_rev = options.lastVersionTag;
        } else if (options.parentRev || options.parent_rev) {
          params.parent_rev = options.parentRev || options.parent_rev;
        }
      }
      this.oauth.addAuthParams('POST', url, params);
      delete params.file;
      fileField = {
        name: 'file',
        value: data,
        fileName: fileName,
        contentType: 'application/octet-stream'
      };
      return DropboxXhr.multipartRequest(url, fileField, params, null, function(error, metadata) {
        return callback(error, DropboxStat.parse(metadata));
      });
    };

    DropboxClient.prototype.writeFileUsingPut = function(path, data, options, callback) {
      var params, url;
      url = "" + this.urls.putFile + "/" + (this.urlEncodePath(path));
      params = {};
      if (options) {
        if (options.noOverwrite) {
          params.overwrite = 'false';
        }
        if (options.lastVersionTag) {
          params.parent_rev = options.lastVersionTag;
        } else if (options.parentRev || options.parent_rev) {
          params.parent_rev = options.parentRev || options.parent_rev;
        }
      }
      this.oauth.addAuthParams('POST', url, params);
      return DropboxXhr.request2('POST', url, params, null, data, null, function(error, metadata) {
        return callback(error, DropboxStat.parse(metadata));
      });
    };

    DropboxClient.prototype.stat = function(path, options, callback) {
      var params, url;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      url = "" + this.urls.metadata + "/" + (this.urlEncodePath(path));
      params = {};
      if (options) {
        if (options.version != null) {
          params.rev = options.version;
        }
        if (options.removed || options.deleted) {
          params.include_deleted = 'true';
        }
        if (options.readDir) {
          params.list = 'true';
          if (options.readDir !== true) {
            params.file_limit = options.readDir.toString();
          }
        }
        if (options.cacheHash) {
          params.hash = options.cacheHash;
        }
      }
      params.include_deleted || (params.include_deleted = 'false');
      params.list || (params.list = 'false');
      this.oauth.addAuthParams('GET', url, params);
      return DropboxXhr.request('GET', url, params, null, function(error, metadata) {
        var entries, entry, stat;
        stat = DropboxStat.parse(metadata);
        if (metadata != null ? metadata.contents : void 0) {
          entries = (function() {
            var _i, _len, _ref, _results;
            _ref = metadata.contents;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              entry = _ref[_i];
              _results.push(DropboxStat.parse(entry));
            }
            return _results;
          })();
        } else {
          entries = void 0;
        }
        return callback(error, stat, entries);
      });
    };

    DropboxClient.prototype.readdir = function(path, options, callback) {
      var statOptions;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      statOptions = {
        readDir: true
      };
      if (options) {
        if (options.limit != null) {
          statOptions.readDir = options.limit;
        }
        if (options.versionTag) {
          statOptions.versionTag = options.versionTag;
        }
      }
      return this.stat(path, statOptions, function(error, stat, entry_stats) {
        var entries, entry_stat;
        if (entry_stats) {
          entries = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = entry_stats.length; _i < _len; _i++) {
              entry_stat = entry_stats[_i];
              _results.push(entry_stat.name);
            }
            return _results;
          })();
        } else {
          entries = null;
        }
        return callback(error, entries, stat, entry_stats);
      });
    };

    DropboxClient.prototype.metadata = function(path, options, callback) {
      return this.stat(path, options, callback);
    };

    DropboxClient.prototype.makeUrl = function(path, options, callback) {
      var isDirect, params, url;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      path = this.urlEncodePath(path);
      if (options && options.download) {
        isDirect = true;
        url = "" + this.urls.media + "/" + path;
      } else {
        isDirect = false;
        url = "" + this.urls.shares + "/" + path;
      }
      if (options && options.long) {
        params = {
          short_url: 'false'
        };
      } else {
        params = {};
      }
      this.oauth.addAuthParams('POST', url, params);
      return DropboxXhr.request('POST', url, params, null, function(error, urlData) {
        return callback(error, DropboxPublicUrl.parse(urlData, isDirect));
      });
    };

    DropboxClient.prototype.history = function(path, options, callback) {
      var params, url;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      url = "" + this.urls.revisions + "/" + (this.urlEncodePath(path));
      params = {};
      if (options && (options.limit != null)) {
        params.rev_limit = options.limit;
      }
      this.oauth.addAuthParams('GET', url, params);
      return DropboxXhr.request('GET', url, params, null, function(error, versions) {
        var metadata, stats;
        if (versions) {
          stats = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = versions.length; _i < _len; _i++) {
              metadata = versions[_i];
              _results.push(DropboxStat.parse(metadata));
            }
            return _results;
          })();
        } else {
          stats = void 0;
        }
        return callback(error, stats);
      });
    };

    DropboxClient.prototype.revisions = function(path, options, callback) {
      return this.history(path, options, callback);
    };

    DropboxClient.prototype.thumbnailUrl = function(path, options) {
      var params, url;
      url = "" + this.urls.thumbnails + "/" + (this.urlEncodePath(path));
      params = {};
      if (options) {
        if (options.format) {
          params.format = options.format;
        } else if (options.png) {
          params.format = 'png';
        }
        if (options.size) {
          params.size = options.size;
        }
      }
      this.oauth.addAuthParams('GET', url, params);
      return "" + url + "?" + (Dropbox.Xhr.urlEncode(params));
    };

    DropboxClient.prototype.readThumbnail = function(path, options, callback) {
      var responseType, url;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      url = this.thumbnailUrl(path, options);
      responseType = 'b';
      if (options) {
        if (options.blob) {
          responseType = 'blob';
        }
      }
      return DropboxXhr.request2('GET', url, {}, null, null, responseType, function(error, data, metadata) {
        return callback(error, data, DropboxStat.parse(metadata));
      });
    };

    DropboxClient.prototype.revertFile = function(path, versionTag, callback) {
      var params, url;
      url = "" + this.urls.restore + "/" + (this.urlEncodePath(path));
      params = {
        rev: versionTag
      };
      this.oauth.addAuthParams('POST', url, params);
      return DropboxXhr.request('POST', url, params, null, function(error, metadata) {
        return callback(error, DropboxStat.parse(metadata));
      });
    };

    DropboxClient.prototype.restore = function(path, versionTag, callback) {
      return this.revertFile(path, versionTag, callback);
    };

    DropboxClient.prototype.findByName = function(path, namePattern, options, callback) {
      var params, url;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      url = "" + this.urls.search + "/" + (this.urlEncodePath(path));
      params = {
        query: namePattern
      };
      if (options) {
        if (options.limit != null) {
          params.file_limit = options.limit;
        }
        if (options.removed || options.deleted) {
          params.include_deleted = true;
        }
      }
      this.oauth.addAuthParams('GET', url, params);
      return DropboxXhr.request('GET', url, params, null, function(error, results) {
        var metadata, stats;
        if (results) {
          stats = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = results.length; _i < _len; _i++) {
              metadata = results[_i];
              _results.push(DropboxStat.parse(metadata));
            }
            return _results;
          })();
        } else {
          stats = void 0;
        }
        return callback(error, stats);
      });
    };

    DropboxClient.prototype.search = function(path, namePattern, options, callback) {
      return this.findByName(path, namePattern, options, callback);
    };

    DropboxClient.prototype.makeCopyReference = function(path, callback) {
      var params, url;
      url = "" + this.urls.copyRef + "/" + (this.urlEncodePath(path));
      params = this.oauth.addAuthParams('GET', url, {});
      return DropboxXhr.request('GET', url, params, null, function(error, refData) {
        return callback(error, DropboxCopyReference.parse(refData));
      });
    };

    DropboxClient.prototype.copyRef = function(path, callback) {
      return this.makeCopyReference(path, callback);
    };

    DropboxClient.prototype.pullChanges = function(cursor, callback) {
      var params, url;
      if ((!callback) && (typeof cursor === 'function')) {
        callback = cursor;
        cursor = null;
      }
      url = this.urls.delta;
      params = {};
      if (cursor) {
        if (cursor.cursorTag) {
          params = {
            cursor: cursor.cursorTag
          };
        } else {
          params = {
            cursor: cursor
          };
        }
      } else {
        params = {};
      }
      this.oauth.addAuthParams('POST', url, params);
      return DropboxXhr.request('POST', url, params, null, function(error, deltaInfo) {
        return callback(error, Dropbox.PulledChanges.parse(deltaInfo));
      });
    };

    DropboxClient.prototype.delta = function(cursor, callback) {
      return this.pullChanges(cursor, callback);
    };

    DropboxClient.prototype.mkdir = function(path, callback) {
      var params, url;
      url = this.urls.fileopsCreateFolder;
      params = {
        root: this.fileRoot,
        path: this.normalizePath(path)
      };
      this.oauth.addAuthParams('POST', url, params);
      return DropboxXhr.request('POST', url, params, null, function(error, metadata) {
        return callback(error, DropboxStat.parse(metadata));
      });
    };

    DropboxClient.prototype.remove = function(path, callback) {
      var params, url;
      url = this.urls.fileopsDelete;
      params = {
        root: this.fileRoot,
        path: this.normalizePath(path)
      };
      this.oauth.addAuthParams('POST', url, params);
      return DropboxXhr.request('POST', url, params, null, function(error, metadata) {
        return callback(error, DropboxStat.parse(metadata));
      });
    };

    DropboxClient.prototype.unlink = function(path, callback) {
      return this.remove(path, callback);
    };

    DropboxClient.prototype["delete"] = function(path, callback) {
      return this.remove(path, callback);
    };

    DropboxClient.prototype.copy = function(from, toPath, callback) {
      var options, params, url;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      params = {
        root: this.fileRoot,
        to_path: this.normalizePath(toPath)
      };
      if (from instanceof DropboxCopyReference) {
        params.from_copy_ref = from.tag;
      } else {
        params.from_path = this.normalizePath(from);
      }
      url = this.urls.fileopsCopy;
      this.oauth.addAuthParams('POST', url, params);
      return DropboxXhr.request('POST', url, params, null, function(error, metadata) {
        return callback(error, DropboxStat.parse(metadata));
      });
    };

    DropboxClient.prototype.move = function(fromPath, toPath, callback) {
      var options, params, url;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      fromPath = this.normalizePath(fromPath);
      toPath = this.normalizePath(toPath);
      url = this.urls.fileopsMove;
      params = {
        root: this.fileRoot,
        from_path: fromPath,
        to_path: toPath
      };
      this.oauth.addAuthParams('POST', url, params);
      return DropboxXhr.request('POST', url, params, null, function(error, metadata) {
        return callback(error, DropboxStat.parse(metadata));
      });
    };

    DropboxClient.prototype.reset = function() {
      this.uid = null;
      this.oauth.setToken(null, '');
      this.authState = DropboxClient.RESET;
      this.authError = null;
      this._credentials = null;
      return this;
    };

    DropboxClient.prototype.setCredentials = function(credentials) {
      this.oauth.reset(credentials);
      this.uid = credentials.uid || null;
      if (credentials.authState) {
        this.authState = credentials.authState;
      } else {
        if (credentials.token) {
          this.authState = DropboxClient.DONE;
        } else {
          this.authState = DropboxClient.RESET;
        }
      }
      this.authError = null;
      this._credentials = null;
      return this;
    };

    DropboxClient.prototype.appHash = function() {
      return this.oauth.appHash();
    };

    DropboxClient.prototype.setupUrls = function() {
      this.fileRoot = this.sandbox ? 'sandbox' : 'dropbox';
      return this.urls = {
        requestToken: "" + this.apiServer + "/1/oauth/request_token",
        authorize: "" + this.authServer + "/1/oauth/authorize",
        accessToken: "" + this.apiServer + "/1/oauth/access_token",
        signOut: "" + this.apiServer + "/1/unlink_access_token",
        accountInfo: "" + this.apiServer + "/1/account/info",
        getFile: "" + this.fileServer + "/1/files/" + this.fileRoot,
        postFile: "" + this.fileServer + "/1/files/" + this.fileRoot,
        putFile: "" + this.fileServer + "/1/files_put/" + this.fileRoot,
        metadata: "" + this.apiServer + "/1/metadata/" + this.fileRoot,
        delta: "" + this.apiServer + "/1/delta",
        revisions: "" + this.apiServer + "/1/revisions/" + this.fileRoot,
        restore: "" + this.apiServer + "/1/restore/" + this.fileRoot,
        search: "" + this.apiServer + "/1/search/" + this.fileRoot,
        shares: "" + this.apiServer + "/1/shares/" + this.fileRoot,
        media: "" + this.apiServer + "/1/media/" + this.fileRoot,
        copyRef: "" + this.apiServer + "/1/copy_ref/" + this.fileRoot,
        thumbnails: "" + this.fileServer + "/1/thumbnails/" + this.fileRoot,
        fileopsCopy: "" + this.apiServer + "/1/fileops/copy",
        fileopsCreateFolder: "" + this.apiServer + "/1/fileops/create_folder",
        fileopsDelete: "" + this.apiServer + "/1/fileops/delete",
        fileopsMove: "" + this.apiServer + "/1/fileops/move"
      };
    };

    DropboxClient.ERROR = 0;

    DropboxClient.RESET = 1;

    DropboxClient.REQUEST = 2;

    DropboxClient.AUTHORIZED = 3;

    DropboxClient.DONE = 4;

    DropboxClient.SIGNED_OFF = 5;

    DropboxClient.prototype.urlEncodePath = function(path) {
      return DropboxXhr.urlEncodeValue(this.normalizePath(path)).replace(/%2F/gi, '/');
    };

    DropboxClient.prototype.normalizePath = function(path) {
      var i;
      if (path.substring(0, 1) === '/') {
        i = 1;
        while (path.substring(i, i + 1) === '/') {
          i += 1;
        }
        return path.substring(i);
      } else {
        return path;
      }
    };

    DropboxClient.prototype.requestToken = function(callback) {
      var params;
      params = this.oauth.addAuthParams('POST', this.urls.requestToken, {});
      return DropboxXhr.request('POST', this.urls.requestToken, params, null, callback);
    };

    DropboxClient.prototype.authorizeUrl = function(token) {
      var params;
      params = {
        oauth_token: token,
        oauth_callback: this.authDriver.url()
      };
      return ("" + this.urls.authorize + "?") + DropboxXhr.urlEncode(params);
    };

    DropboxClient.prototype.getAccessToken = function(callback) {
      var params;
      params = this.oauth.addAuthParams('POST', this.urls.accessToken, {});
      return DropboxXhr.request('POST', this.urls.accessToken, params, null, callback);
    };

    DropboxClient.prototype.defaultApiServer = function() {
      return 'https://api.dropbox.com';
    };

    DropboxClient.prototype.defaultAuthServer = function() {
      return this.apiServer.replace('api.', 'www.');
    };

    DropboxClient.prototype.defaultFileServer = function() {
      return this.apiServer.replace('api.', 'api-content.');
    };

    DropboxClient.prototype.computeCredentials = function() {
      var value;
      value = {
        key: this.oauth.key,
        sandbox: this.sandbox
      };
      if (this.oauth.secret) {
        value.secret = this.oauth.secret;
      }
      if (this.oauth.token) {
        value.token = this.oauth.token;
        value.tokenSecret = this.oauth.tokenSecret;
      }
      if (this.uid) {
        value.uid = this.uid;
      }
      if (this.authState !== DropboxClient.ERROR && this.authState !== DropboxClient.RESET && this.authState !== DropboxClient.DONE && this.authState !== DropboxClient.SIGNED_OFF) {
        value.authState = this.authState;
      }
      if (this.apiServer !== this.defaultApiServer()) {
        value.server = this.apiServer;
      }
      if (this.authServer !== this.defaultAuthServer()) {
        value.authServer = this.authServer;
      }
      if (this.fileServer !== this.defaultFileServer()) {
        value.fileServer = this.fileServer;
      }
      return this._credentials = value;
    };

    return DropboxClient;

  })();

  DropboxAuthDriver = (function() {

    function DropboxAuthDriver() {}

    DropboxAuthDriver.prototype.url = function() {
      return 'https://some.url';
    };

    DropboxAuthDriver.prototype.doAuthorize = function(authUrl, token, tokenSecret, callback) {
      return callback('oauth-token');
    };

    DropboxAuthDriver.prototype.onAuthStateChange = function(client, done) {
      return done();
    };

    return DropboxAuthDriver;

  })();

  DropboxRedirectDriver = (function() {

    function DropboxRedirectDriver(options) {
      this.rememberUser = (options != null ? options.rememberUser : void 0) || false;
      this.scope = (options != null ? options.scope : void 0) || 'default';
      this.useQuery = (options != null ? options.useQuery : void 0) || false;
      this.receiverUrl = this.computeUrl(options);
      this.tokenRe = new RegExp("(#|\\?|&)oauth_token=([^&#]+)(&|#|$)");
    }

    DropboxRedirectDriver.prototype.url = function() {
      return this.receiverUrl;
    };

    DropboxRedirectDriver.prototype.doAuthorize = function(authUrl, token, tokenSecret, callback) {
      return window.location.assign(authUrl);
    };

    DropboxRedirectDriver.prototype.onAuthStateChange = function(client, done) {
      var credentials,
        _this = this;
      this.storageKey = "dropbox-auth:" + this.scope + ":" + (client.appHash());
      switch (client.authState) {
        case Dropbox.Client.RESET:
          if (!(credentials = this.loadCredentials())) {
            return done();
          }
          if (credentials.authState) {
            if (credentials.token === this.locationToken()) {
              if (credentials.authState === DropboxClient.REQUEST) {
                this.forgetCredentials();
                credentials.authState = DropboxClient.AUTHORIZED;
              }
              client.setCredentials(credentials);
            }
            return done();
          }
          if (!this.rememberUser) {
            this.forgetCredentials();
            return done();
          }
          client.setCredentials(credentials);
          return client.getUserInfo(function(error, userInfo) {
            if (error) {
              client.reset();
              _this.forgetCredentials();
            }
            return done();
          });
        case DropboxClient.REQUEST:
          this.storeCredentials(client.credentials());
          return done();
        case DropboxClient.DONE:
          if (this.rememberUser) {
            this.storeCredentials(client.credentials());
          }
          return done();
        case DropboxClient.SIGNED_OFF:
          this.forgetCredentials();
          return done();
        case DropboxClient.ERROR:
          this.forgetCredentials();
          return done();
        default:
          return done();
      }
    };

    DropboxRedirectDriver.prototype.computeUrl = function() {
      var fragment, location, locationPair, querySuffix;
      querySuffix = "_dropboxjs_scope=" + (encodeURIComponent(this.scope));
      location = DropboxRedirectDriver.currentLocation();
      if (location.indexOf('#') === -1) {
        fragment = null;
      } else {
        locationPair = location.split('#', 2);
        location = locationPair[0];
        fragment = locationPair[1];
      }
      if (this.useQuery) {
        if (location.indexOf('?') === -1) {
          location += "?" + querySuffix;
        } else {
          location += "&" + querySuffix;
        }
      } else {
        fragment = "?" + querySuffix;
      }
      if (fragment) {
        return location + '#' + fragment;
      } else {
        return location;
      }
    };

    DropboxRedirectDriver.prototype.locationToken = function() {
      var location, match, scopePattern;
      location = DropboxRedirectDriver.currentLocation();
      scopePattern = "_dropboxjs_scope=" + (encodeURIComponent(this.scope)) + "&";
      if ((typeof location.indexOf === "function" ? location.indexOf(scopePattern) : void 0) === -1) {
        return null;
      }
      match = this.tokenRe.exec(location);
      if (match) {
        return decodeURIComponent(match[2]);
      } else {
        return null;
      }
    };

    DropboxRedirectDriver.currentLocation = function() {
      return window.location.href;
    };

    DropboxRedirectDriver.prototype.storeCredentials = function(credentials) {
      return localStorage.setItem(this.storageKey, JSON.stringify(credentials));
    };

    DropboxRedirectDriver.prototype.loadCredentials = function() {
      var jsonString;
      jsonString = localStorage.getItem(this.storageKey);
      if (!jsonString) {
        return null;
      }
      try {
        return JSON.parse(jsonString);
      } catch (e) {
        return null;
      }
    };

    DropboxRedirectDriver.prototype.forgetCredentials = function() {
      return localStorage.removeItem(this.storageKey);
    };

    return DropboxRedirectDriver;

  })();

  DropboxPopupDriver = (function() {

    function DropboxPopupDriver(options) {
      this.receiverUrl = this.computeUrl(options);
      this.tokenRe = new RegExp("(#|\\?|&)oauth_token=([^&#]+)(&|#|$)");
    }

    DropboxPopupDriver.prototype.doAuthorize = function(authUrl, token, tokenSecret, callback) {
      this.listenForMessage(token, callback);
      return this.openWindow(authUrl);
    };

    DropboxPopupDriver.prototype.url = function() {
      return this.receiverUrl;
    };

    DropboxPopupDriver.prototype.computeUrl = function(options) {
      var fragments;
      if (options) {
        if (options.receiverUrl) {
          return options.receiverUrl;
        } else if (options.receiverFile) {
          fragments = DropboxPopupDriver.currentLocation().split('/');
          fragments[fragments.length - 1] = options.receiverFile;
          return fragments.join('/') + '#';
        }
      }
      return DropboxPopupDriver.currentLocation();
    };

    DropboxPopupDriver.currentLocation = function() {
      return window.location.href;
    };

    DropboxPopupDriver.prototype.openWindow = function(url) {
      return window.open(url, '_dropboxOauthSigninWindow', this.popupWindowSpec(980, 980));
    };

    DropboxPopupDriver.prototype.popupWindowSpec = function(popupWidth, popupHeight) {
      var height, popupLeft, popupTop, width, x0, y0, _ref, _ref1, _ref2, _ref3;
      x0 = (_ref = window.screenX) != null ? _ref : window.screenLeft;
      y0 = (_ref1 = window.screenY) != null ? _ref1 : window.screenTop;
      width = (_ref2 = window.outerWidth) != null ? _ref2 : document.documentElement.clientWidth;
      height = (_ref3 = window.outerHeight) != null ? _ref3 : document.documentElement.clientHeight;
      popupLeft = Math.round(x0 + (width - popupWidth) / 2);
      popupTop = Math.round(y0 + (height - popupHeight) / 2.5);
      return ("width=" + popupWidth + ",height=" + popupHeight + ",") + ("left=" + popupLeft + ",top=" + popupTop) + 'dialog=yes,dependent=yes,scrollbars=yes,location=yes';
    };

    DropboxPopupDriver.prototype.listenForMessage = function(token, callback) {
      var listener, tokenRe;
      tokenRe = this.tokenRe;
      listener = function(event) {
        var match;
        match = tokenRe.exec(event.data.toString());
        if (match && decodeURIComponent(match[2]) === token) {
          callback();
          return window.removeEventListener('message', listener);
        }
      };
      return window.addEventListener('message', listener, false);
    };

    return DropboxPopupDriver;

  })();

  DropboxNodeServerDriver = (function() {

    function DropboxNodeServerDriver(options) {
      this.port = (options != null ? options.port : void 0) || 8912;
      this.faviconFile = (options != null ? options.favicon : void 0) || null;
      this.fs = require('fs');
      this.http = require('http');
      this.open = require('open');
      this.callbacks = {};
      this.urlRe = new RegExp("^/oauth_callback\\?");
      this.tokenRe = new RegExp("(\\?|&)oauth_token=([^&]+)(&|$)");
      this.createApp();
    }

    DropboxNodeServerDriver.prototype.url = function() {
      return "http://localhost:" + this.port + "/oauth_callback";
    };

    DropboxNodeServerDriver.prototype.doAuthorize = function(authUrl, token, tokenSecret, callback) {
      this.callbacks[token] = callback;
      return this.openBrowser(authUrl);
    };

    DropboxNodeServerDriver.prototype.openBrowser = function(url) {
      if (!url.match(/^https?:\/\//)) {
        throw new Error("Not a http/https URL: " + url);
      }
      return this.open(url);
    };

    DropboxNodeServerDriver.prototype.createApp = function() {
      var _this = this;
      this.app = this.http.createServer(function(request, response) {
        return _this.doRequest(request, response);
      });
      return this.app.listen(this.port);
    };

    DropboxNodeServerDriver.prototype.closeServer = function() {
      return this.app.close();
    };

    DropboxNodeServerDriver.prototype.doRequest = function(request, response) {
      var data, match, token,
        _this = this;
      if (this.urlRe.exec(request.url)) {
        match = this.tokenRe.exec(request.url);
        if (match) {
          token = decodeURIComponent(match[2]);
          if (this.callbacks[token]) {
            this.callbacks[token]();
            delete this.callbacks[token];
          }
        }
      }
      data = '';
      request.on('data', function(dataFragment) {
        return data += dataFragment;
      });
      return request.on('end', function() {
        if (_this.faviconFile && (request.url === '/favicon.ico')) {
          return _this.sendFavicon(response);
        } else {
          return _this.closeBrowser(response);
        }
      });
    };

    DropboxNodeServerDriver.prototype.closeBrowser = function(response) {
      var closeHtml;
      closeHtml = "<!doctype html>\n<script type=\"text/javascript\">window.close();</script>\n<p>Please close this window.</p>";
      response.writeHead(200, {
        'Content-Length': closeHtml.length,
        'Content-Type': 'text/html'
      });
      response.write(closeHtml);
      return response.end;
    };

    DropboxNodeServerDriver.prototype.sendFavicon = function(response) {
      return this.fs.readFile(this.faviconFile, function(error, data) {
        response.writeHead(200, {
          'Content-Length': data.length,
          'Content-Type': 'image/x-icon'
        });
        response.write(data);
        return response.end;
      });
    };

    return DropboxNodeServerDriver;

  })();

  Dropbox = (function() {

    function Dropbox(options) {
      this.client = new DropboxClient(options);
    }

    return Dropbox;

  })();

  base64HmacSha1 = function(string, key) {
    return arrayToBase64(hmacSha1(stringToArray(string), stringToArray(key), string.length, key.length));
  };

  base64Sha1 = function(string) {
    return arrayToBase64(sha1(stringToArray(string), string.length));
  };

  if (typeof window === "undefined" || window === null) {
    crypto = require('crypto');
    base64HmacSha1 = function(string, key) {
      var hmac;
      hmac = crypto.createHmac('sha1', key);
      hmac.update(string);
      return hmac.digest('base64');
    };
    base64Sha1 = function(string) {
      var hash;
      hash = crypto.createHash('sha1');
      hash.update(string);
      return hash.digest('base64');
    };
  }

  hmacSha1 = function(string, key, length, keyLength) {
    var hash1, i, ipad, opad;
    if (key.length > 16) {
      key = sha1(key, keyLength);
    }
    ipad = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; _i < 16; i = ++_i) {
        _results.push(key[i] ^ 0x36363636);
      }
      return _results;
    })();
    opad = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; _i < 16; i = ++_i) {
        _results.push(key[i] ^ 0x5C5C5C5C);
      }
      return _results;
    })();
    hash1 = sha1(ipad.concat(string), 64 + length);
    return sha1(opad.concat(hash1), 64 + 20);
  };

  sha1 = function(string, length) {
    var a, a0, b, b0, c, c0, d, d0, e, e0, ft, i, j, kt, limit, state, t, _i;
    string[length >> 2] |= 1 << (31 - ((length & 0x03) << 3));
    string[(((length + 8) >> 6) << 4) + 15] = length << 3;
    state = Array(80);
    a = 1732584193;
    b = -271733879;
    c = -1732584194;
    d = 271733878;
    e = -1009589776;
    i = 0;
    limit = string.length;
    while (i < limit) {
      a0 = a;
      b0 = b;
      c0 = c;
      d0 = d;
      e0 = e;
      for (j = _i = 0; _i < 80; j = ++_i) {
        if (j < 16) {
          state[j] = string[i + j];
        } else {
          state[j] = rotateLeft32(state[j - 3] ^ state[j - 8] ^ state[j - 14] ^ state[j - 16], 1);
        }
        if (j < 20) {
          ft = (b & c) | ((~b) & d);
          kt = 1518500249;
        } else if (j < 40) {
          ft = b ^ c ^ d;
          kt = 1859775393;
        } else if (j < 60) {
          ft = (b & c) | (b & d) | (c & d);
          kt = -1894007588;
        } else {
          ft = b ^ c ^ d;
          kt = -899497514;
        }
        t = add32(add32(rotateLeft32(a, 5), ft), add32(add32(e, state[j]), kt));
        e = d;
        d = c;
        c = rotateLeft32(b, 30);
        b = a;
        a = t;
      }
      a = add32(a, a0);
      b = add32(b, b0);
      c = add32(c, c0);
      d = add32(d, d0);
      e = add32(e, e0);
      i += 16;
    }
    return [a, b, c, d, e];
  };

  /*
  # Uncomment the definition below for debugging.
  #
  # Returns the hexadecimal representation of a 32-bit number.
  xxx = (n) ->
    if n < 0
      n = (1 << 30) * 4 + n
    n.toString 16
  */


  rotateLeft32 = function(value, count) {
    return (value << count) | (value >>> (32 - count));
  };

  add32 = function(a, b) {
    var high, low;
    low = (a & 0xFFFF) + (b & 0xFFFF);
    high = (a >> 16) + (b >> 16) + (low >> 16);
    return (high << 16) | (low & 0xFFFF);
  };

  arrayToBase64 = function(array) {
    var i, i2, limit, string, trit;
    string = "";
    i = 0;
    limit = array.length * 4;
    while (i < limit) {
      i2 = i;
      trit = ((array[i2 >> 2] >> ((3 - (i2 & 3)) << 3)) & 0xFF) << 16;
      i2 += 1;
      trit |= ((array[i2 >> 2] >> ((3 - (i2 & 3)) << 3)) & 0xFF) << 8;
      i2 += 1;
      trit |= (array[i2 >> 2] >> ((3 - (i2 & 3)) << 3)) & 0xFF;
      string += _base64Digits[(trit >> 18) & 0x3F];
      string += _base64Digits[(trit >> 12) & 0x3F];
      i += 1;
      if (i >= limit) {
        string += '=';
      } else {
        string += _base64Digits[(trit >> 6) & 0x3F];
      }
      i += 1;
      if (i >= limit) {
        string += '=';
      } else {
        string += _base64Digits[trit & 0x3F];
      }
      i += 1;
    }
    return string;
  };

  _base64Digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  stringToArray = function(string) {
    var array, i, mask, _i, _ref;
    array = [];
    mask = 0xFF;
    for (i = _i = 0, _ref = string.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      array[i >> 2] |= (string.charCodeAt(i) & mask) << ((3 - (i & 3)) << 3);
    }
    return array;
  };

  DropboxOauth = (function() {

    function DropboxOauth(options) {
      this.key = this.k = null;
      this.secret = this.s = null;
      this.token = null;
      this.tokenSecret = null;
      this._appHash = null;
      this.reset(options);
    }

    DropboxOauth.prototype.reset = function(options) {
      var k, s, secret, _ref;
      if (options.secret) {
        this.k = this.key = options.key;
        this.s = this.secret = options.secret;
        this._appHash = null;
      } else if (options.key) {
        this.key = options.key;
        this.secret = null;
        secret = atob(dropboxEncodeKey(this.key).split('|', 2)[1]);
        _ref = secret.split('?', 2), k = _ref[0], s = _ref[1];
        this.k = decodeURIComponent(k);
        this.s = decodeURIComponent(s);
        this._appHash = null;
      }
      if (options.token) {
        return this.setToken(options.token, options.tokenSecret);
      } else {
        return this.setToken(null, '');
      }
    };

    DropboxOauth.prototype.setToken = function(token, tokenSecret) {
      if (token && (!tokenSecret)) {
        throw new Error('No secret supplied with the user token');
      }
      this.token = token;
      this.tokenSecret = tokenSecret || '';
      this.hmacKey = DropboxXhr.urlEncodeValue(this.s) + '&' + DropboxXhr.urlEncodeValue(tokenSecret);
      return null;
    };

    DropboxOauth.prototype.authHeader = function(method, url, params) {
      var header, oauth_params, param, value, _i, _len;
      this.addAuthParams(method, url, params);
      oauth_params = [];
      for (param in params) {
        value = params[param];
        if (param.substring(0, 6) === 'oauth_') {
          oauth_params.push(param);
        }
      }
      oauth_params.sort();
      header = [];
      for (_i = 0, _len = oauth_params.length; _i < _len; _i++) {
        param = oauth_params[_i];
        header.push(DropboxXhr.urlEncodeValue(param) + '="' + DropboxXhr.urlEncodeValue(params[param]) + '"');
        delete params[param];
      }
      return 'OAuth ' + header.join(',');
    };

    DropboxOauth.prototype.addAuthParams = function(method, url, params) {
      this.boilerplateParams(params);
      params.oauth_signature = this.signature(method, url, params);
      return params;
    };

    DropboxOauth.prototype.boilerplateParams = function(params) {
      params.oauth_consumer_key = this.k;
      params.oauth_nonce = this.nonce();
      params.oauth_signature_method = 'HMAC-SHA1';
      if (this.token) {
        params.oauth_token = this.token;
      }
      params.oauth_timestamp = Math.floor(Date.now() / 1000);
      params.oauth_version = '1.0';
      return params;
    };

    DropboxOauth.prototype.nonce = function() {
      return Date.now().toString(36) + Math.random().toString(36);
    };

    DropboxOauth.prototype.signature = function(method, url, params) {
      var string;
      string = method.toUpperCase() + '&' + DropboxXhr.urlEncodeValue(url) + '&' + DropboxXhr.urlEncodeValue(DropboxXhr.urlEncode(params));
      return base64HmacSha1(string, this.hmacKey);
    };

    DropboxOauth.prototype.appHash = function() {
      if (this._appHash) {
        return this._appHash;
      }
      return this._appHash = base64Sha1(this.k).replace(/\=/g, '');
    };

    return DropboxOauth;

  })();

  if (Date.now == null) {
    Date.now = function() {
      return (new Date()).getTime();
    };
  }

  dropboxEncodeKey = function(key, secret) {
    var i, k, result, s, x, y, z, _i, _j, _ref, _ref1, _results;
    if (secret) {
      secret = [encodeURIComponent(key), encodeURIComponent(secret)].join('?');
      key = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = key.length / 2; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(((key.charCodeAt(i * 2) & 15) * 16) + (key.charCodeAt(i * 2 + 1) & 15));
        }
        return _results;
      })();
    } else {
      _ref = key.split('|', 2), key = _ref[0], secret = _ref[1];
      key = atob(key);
      key = (function() {
        var _i, _ref1, _results;
        _results = [];
        for (i = _i = 0, _ref1 = key.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
          _results.push(key.charCodeAt(i));
        }
        return _results;
      })();
      secret = atob(secret);
    }
    s = (function() {
      _results = [];
      for (_i = 0; _i < 256; _i++){ _results.push(_i); }
      return _results;
    }).apply(this);
    y = 0;
    for (x = _j = 0; _j < 256; x = ++_j) {
      y = (y + s[i] + key[x % key.length]) % 256;
      _ref1 = [s[y], s[x]], s[x] = _ref1[0], s[y] = _ref1[1];
    }
    x = y = 0;
    result = (function() {
      var _k, _ref2, _ref3, _results1;
      _results1 = [];
      for (z = _k = 0, _ref2 = secret.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; z = 0 <= _ref2 ? ++_k : --_k) {
        x = (x + 1) % 256;
        y = (y + s[x]) % 256;
        _ref3 = [s[y], s[x]], s[x] = _ref3[0], s[y] = _ref3[1];
        k = s[(s[x] + s[y]) % 256];
        _results1.push(String.fromCharCode((k ^ secret.charCodeAt(z)) % 256));
      }
      return _results1;
    })();
    key = (function() {
      var _k, _ref2, _results1;
      _results1 = [];
      for (i = _k = 0, _ref2 = key.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
        _results1.push(String.fromCharCode(key[i]));
      }
      return _results1;
    })();
    return [btoa(key.join('')), btoa(result.join(''))].join('|');
  };

  DropboxPulledChanges = (function() {

    DropboxPulledChanges.parse = function(deltaInfo) {
      if (deltaInfo && typeof deltaInfo === 'object') {
        return new DropboxPulledChanges(deltaInfo);
      } else {
        return deltaInfo;
      }
    };

    DropboxPulledChanges.prototype.blankSlate = void 0;

    DropboxPulledChanges.prototype.cursorTag = void 0;

    DropboxPulledChanges.prototype.changes = void 0;

    DropboxPulledChanges.prototype.shouldPullAgain = void 0;

    DropboxPulledChanges.prototype.shouldBackOff = void 0;

    function DropboxPulledChanges(deltaInfo) {
      var entry;
      this.blankSlate = deltaInfo.reset || false;
      this.cursorTag = deltaInfo.cursor;
      this.shouldPullAgain = deltaInfo.has_more;
      this.shouldBackOff = !this.shouldPullAgain;
      if (deltaInfo.cursor && deltaInfo.cursor.length) {
        this.changes = (function() {
          var _i, _len, _ref, _results;
          _ref = deltaInfo.entries;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            entry = _ref[_i];
            _results.push(DropboxPullChange.parse(entry));
          }
          return _results;
        })();
      } else {
        this.changes = [];
      }
    }

    return DropboxPulledChanges;

  })();

  DropboxPullChange = (function() {

    DropboxPullChange.parse = function(entry) {
      if (entry && typeof entry === 'object') {
        return new DropboxPullChange(entry);
      } else {
        return entry;
      }
    };

    DropboxPullChange.prototype.path = void 0;

    DropboxPullChange.prototype.wasRemoved = void 0;

    DropboxPullChange.prototype.stat = void 0;

    function DropboxPullChange(entry) {
      this.path = entry[0];
      this.stat = DropboxStat.parse(entry[1]);
      if (this.stat) {
        this.wasRemoved = false;
      } else {
        this.stat = null;
        this.wasRemoved = true;
      }
    }

    return DropboxPullChange;

  })();

  DropboxPublicUrl = (function() {

    DropboxPublicUrl.parse = function(urlData, isDirect) {
      if (urlData && typeof urlData === 'object') {
        return new DropboxPublicUrl(urlData, isDirect);
      } else {
        return urlData;
      }
    };

    DropboxPublicUrl.prototype.url = void 0;

    DropboxPublicUrl.prototype.expiresAt = void 0;

    DropboxPublicUrl.prototype.isDirect = void 0;

    DropboxPublicUrl.prototype.isPreview = void 0;

    function DropboxPublicUrl(urlData, isDirect) {
      this.url = urlData.url;
      this.expiresAt = new Date(Date.parse(urlData.expires));
      if (isDirect === true) {
        this.isDirect = true;
      } else if (isDirect === false) {
        this.isDirect = false;
      } else {
        this.isDirect = Date.now() - this.expiresAt <= 86400000;
      }
      this.isPreview = !this.isDirect;
    }

    return DropboxPublicUrl;

  })();

  DropboxCopyReference = (function() {

    DropboxCopyReference.parse = function(refData) {
      if (refData && (typeof refData === 'object' || typeof refData === 'string')) {
        return new DropboxCopyReference(refData);
      } else {
        return refData;
      }
    };

    DropboxCopyReference.prototype.tag = void 0;

    DropboxCopyReference.prototype.expiresAt = void 0;

    function DropboxCopyReference(refData) {
      if (typeof refData === 'object') {
        this.tag = refData.copy_ref;
        this.expiresAt = new Date(Date.parse(refData.expires));
      } else {
        this.tag = refData;
        this.expiresAt = new Date();
      }
    }

    return DropboxCopyReference;

  })();

  DropboxStat = (function() {

    DropboxStat.parse = function(metadata) {
      if (metadata && typeof metadata === 'object') {
        return new DropboxStat(metadata);
      } else {
        return metadata;
      }
    };

    DropboxStat.prototype.path = null;

    DropboxStat.prototype.name = null;

    DropboxStat.prototype.inAppFolder = null;

    DropboxStat.prototype.isFolder = null;

    DropboxStat.prototype.isFile = null;

    DropboxStat.prototype.isRemoved = null;

    DropboxStat.prototype.typeIcon = null;

    DropboxStat.prototype.versionTag = null;

    DropboxStat.prototype.mimeType = null;

    DropboxStat.prototype.size = null;

    DropboxStat.prototype.humanSize = null;

    DropboxStat.prototype.hasThumbnail = null;

    DropboxStat.prototype.modifiedAt = null;

    DropboxStat.prototype.clientModifiedAt = null;

    function DropboxStat(metadata) {
      var lastIndex, nameSlash, _ref, _ref1;
      this.path = metadata.path;
      if (this.path.substring(0, 1) !== '/') {
        this.path = '/' + this.path;
      }
      lastIndex = this.path.length - 1;
      if (lastIndex >= 0 && this.path.substring(lastIndex) === '/') {
        this.path = this.path.substring(0, lastIndex);
      }
      nameSlash = this.path.lastIndexOf('/');
      this.name = this.path.substring(nameSlash + 1);
      this.isFolder = metadata.is_dir || false;
      this.isFile = !this.isFolder;
      this.isRemoved = metadata.is_deleted || false;
      this.typeIcon = metadata.icon;
      if ((_ref = metadata.modified) != null ? _ref.length : void 0) {
        this.modifiedAt = new Date(Date.parse(metadata.modified));
      } else {
        this.modifiedAt = null;
      }
      if ((_ref1 = metadata.client_mtime) != null ? _ref1.length : void 0) {
        this.clientModifiedAt = new Date(Date.parse(metadata.client_mtime));
      } else {
        this.clientModifiedAt = null;
      }
      switch (metadata.root) {
        case 'dropbox':
          this.inAppFolder = false;
          break;
        case 'app_folder':
          this.inAppFolder = true;
          break;
        default:
          this.inAppFolder = null;
      }
      this.size = metadata.bytes || 0;
      this.humanSize = metadata.size || '';
      this.hasThumbnail = metadata.thumb_exists || false;
      if (this.isFolder) {
        this.versionTag = metadata.hash;
        this.mimeType = metadata.mime_type || 'inode/directory';
      } else {
        this.versionTag = metadata.rev;
        this.mimeType = metadata.mime_type || 'application/octet-stream';
      }
    }

    return DropboxStat;

  })();

  DropboxUserInfo = (function() {

    DropboxUserInfo.parse = function(userInfo) {
      if (userInfo && typeof userInfo === 'object') {
        return new DropboxUserInfo(userInfo);
      } else {
        return userInfo;
      }
    };

    DropboxUserInfo.prototype.name = null;

    DropboxUserInfo.prototype.email = null;

    DropboxUserInfo.prototype.countryCode = null;

    DropboxUserInfo.prototype.uid = null;

    DropboxUserInfo.prototype.referralUrl = null;

    DropboxUserInfo.prototype.publicAppUrl = null;

    DropboxUserInfo.prototype.quota = null;

    DropboxUserInfo.prototype.usedQuota = null;

    DropboxUserInfo.prototype.privateBytes = null;

    DropboxUserInfo.prototype.sharedBytes = null;

    function DropboxUserInfo(userInfo) {
      var lastIndex;
      this.name = userInfo.display_name;
      this.email = userInfo.email;
      this.countryCode = userInfo.country || null;
      this.uid = userInfo.uid.toString();
      if (userInfo.public_app_url) {
        this.publicAppUrl = userInfo.public_app_url;
        lastIndex = this.publicAppUrl.length - 1;
        if (lastIndex >= 0 && this.publicAppUrl.substring(lastIndex) === '/') {
          this.publicAppUrl = this.publicAppUrl.substring(0, lastIndex);
        }
      } else {
        this.publicAppUrl = null;
      }
      this.referralUrl = userInfo.referral_link;
      this.quota = userInfo.quota_info.quota;
      this.privateBytes = userInfo.quota_info.normal || 0;
      this.sharedBytes = userInfo.quota_info.shared || 0;
      this.usedQuota = this.privateBytes + this.sharedBytes;
    }

    return DropboxUserInfo;

  })();

  if (typeof window !== "undefined" && window !== null) {
    if (window.XDomainRequest && !('withCredentials' in new XMLHttpRequest())) {
      DropboxXhrRequest = window.XDomainRequest;
      DropboxXhrIeMode = true;
      DropboxXhrCanSendForms = false;
    } else {
      DropboxXhrRequest = window.XMLHttpRequest;
      DropboxXhrIeMode = false;
      DropboxXhrCanSendForms = window.navigator.userAgent.indexOf('Firefox') === -1;
    }
  } else {
    DropboxXhrRequest = require('xmlhttprequest').XMLHttpRequest;
    DropboxXhrIeMode = false;
    DropboxXhrCanSendForms = false;
  }

  DropboxXhr = (function() {

    function DropboxXhr() {}

    DropboxXhr.Request = DropboxXhrRequest;

    DropboxXhr.ieMode = DropboxXhrIeMode;

    DropboxXhr.canSendForms = DropboxXhrCanSendForms;

    DropboxXhr.request = function(method, url, params, authHeader, callback) {
      return this.request2(method, url, params, authHeader, null, null, callback);
    };

    DropboxXhr.request2 = function(method, url, params, authHeader, body, responseType, callback) {
      var headers, paramsInUrl, queryString;
      paramsInUrl = method === 'GET' || (body != null) || this.ieMode;
      if (paramsInUrl) {
        queryString = DropboxXhr.urlEncode(params);
        if (queryString.length !== 0) {
          url = [url, '?', DropboxXhr.urlEncode(params)].join('');
        }
      }
      headers = {};
      if (authHeader) {
        headers['Authorization'] = authHeader;
      }
      if (body != null) {
        if (typeof body === 'string') {
          headers['Content-Type'] = 'text/plain; charset=utf8';
        }
      } else if (!paramsInUrl) {
        headers['Content-Type'] = 'application/x-www-form-urlencoded';
        body = DropboxXhr.urlEncode(params);
      }
      return DropboxXhr.xhrRequest(method, url, headers, body, responseType, callback);
    };

    DropboxXhr.multipartRequest = function(url, fileField, params, authHeader, callback) {
      var body, boundary, fileData, fileType, headers, useFormData;
      url = [url, '?', DropboxXhr.urlEncode(params)].join('');
      fileData = fileField.value;
      useFormData = (typeof fileData === 'object') && (((typeof Blob !== "undefined" && Blob !== null) && (fileField.value instanceof Blob)) || ((typeof File !== "undefined" && File !== null) && (fileField.value instanceof File)));
      if (useFormData) {
        headers = {};
        body = new FormData();
        body.append(fileField.name, fileData, fileField.fileName);
      } else {
        fileType = fileField.contentType || 'application/octet-stream';
        boundary = this.multipartBoundary();
        headers = {
          'Content-Type': "multipart/form-data; boundary=" + boundary
        };
        body = ['--', boundary, "\r\n", 'Content-Disposition: form-data; name="', fileField.name, '"; filename="', fileField.fileName, "\"\r\n", 'Content-Type: ', fileType, "\r\n", "Content-Transfer-Encoding: binary\r\n\r\n", fileData, "\r\n", '--', boundary, '--', "\r\n"].join('');
      }
      if (authHeader) {
        headers['Authorization'] = authHeader;
      }
      return DropboxXhr.xhrRequest('POST', url, headers, body, null, callback);
    };

    DropboxXhr.multipartBoundary = function() {
      return [Date.now().toString(36), Math.random().toString(36)].join('----');
    };

    DropboxXhr.xhrRequest = function(method, url, headers, body, responseType, callback) {
      var header, value, xhr;
      xhr = new this.Request();
      if (this.ieMode) {
        xhr.onload = function() {
          return DropboxXhr.onLoad(xhr, method, url, callback);
        };
        xhr.onerror = function() {
          return DropboxXhr.onError(xhr, method, url, callback);
        };
      } else {
        xhr.onreadystatechange = function() {
          return DropboxXhr.onReadyStateChange(xhr, method, url, responseType, callback);
        };
      }
      xhr.open(method, url, true);
      if (responseType) {
        if (responseType === 'b') {
          if (xhr.overrideMimeType) {
            xhr.overrideMimeType('text/plain; charset=x-user-defined');
          }
        } else {
          xhr.responseType = responseType;
        }
      }
      if (!this.ieMode) {
        for (header in headers) {
          if (!__hasProp.call(headers, header)) continue;
          value = headers[header];
          xhr.setRequestHeader(header, value);
        }
      }
      if (body != null) {
        xhr.send(body);
      } else {
        xhr.send();
      }
      return xhr;
    };

    DropboxXhr.urlEncode = function(object) {
      var chunks, key, value;
      chunks = [];
      for (key in object) {
        value = object[key];
        chunks.push(this.urlEncodeValue(key) + '=' + this.urlEncodeValue(value));
      }
      return chunks.sort().join('&');
    };

    DropboxXhr.urlEncodeValue = function(object) {
      return encodeURIComponent(object.toString()).replace(/\!/g, '%21').replace(/'/g, '%27').replace(/\(/g, '%28').replace(/\)/g, '%29').replace(/\*/g, '%2A');
    };

    DropboxXhr.urlDecode = function(string) {
      var kvp, result, token, _i, _len, _ref;
      result = {};
      _ref = string.split('&');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        token = _ref[_i];
        kvp = token.split('=');
        result[decodeURIComponent(kvp[0])] = decodeURIComponent(kvp[1]);
      }
      return result;
    };

    DropboxXhr.onReadyStateChange = function(xhr, method, url, responseType, callback) {
      var apiError, bytes, dirtyText, i, metadata, metadataJson, text, _i, _ref;
      if (xhr.readyState !== 4) {
        return true;
      }
      if (xhr.status < 200 || xhr.status >= 300) {
        apiError = new DropboxApiError(xhr, method, url);
        callback(apiError);
        return true;
      }
      metadataJson = xhr.getResponseHeader('x-dropbox-metadata');
      if (metadataJson != null ? metadataJson.length : void 0) {
        try {
          metadata = JSON.parse(metadataJson);
        } catch (e) {
          metadata = void 0;
        }
      } else {
        metadata = void 0;
      }
      if (responseType) {
        if (responseType === 'b') {
          dirtyText = xhr.responseText != null ? xhr.responseText : xhr.response;
          /*
                  jsString = ['["']
                  for i in [0...dirtyText.length]
                    hexByte = (dirtyText.charCodeAt(i) & 0xFF).toString(16)
                    if hexByte.length is 2
                      jsString.push "\\u00#{hexByte}"
                    else
                      jsString.push "\\u000#{hexByte}"
                  jsString.push '"]'
                  console.log jsString
                  text = JSON.parse(jsString.join(''))[0]
          */

          bytes = [];
          for (i = _i = 0, _ref = dirtyText.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            bytes.push(String.fromCharCode(dirtyText.charCodeAt(i) & 0xFF));
          }
          text = bytes.join('');
          callback(null, text, metadata);
        } else {
          callback(null, xhr.response, metadata);
        }
        return true;
      }
      text = xhr.responseText != null ? xhr.responseText : xhr.response;
      switch (xhr.getResponseHeader('Content-Type')) {
        case 'application/x-www-form-urlencoded':
          callback(null, DropboxXhr.urlDecode(text), metadata);
          break;
        case 'application/json':
        case 'text/javascript':
          callback(null, JSON.parse(text), metadata);
          break;
        default:
          callback(null, text, metadata);
      }
      return true;
    };

    DropboxXhr.onLoad = function(xhr, method, url, callback) {
      var text;
      text = xhr.responseText;
      switch (xhr.contentType) {
        case 'application/x-www-form-urlencoded':
          callback(null, DropboxXhr.urlDecode(text), void 0);
          break;
        case 'application/json':
        case 'text/javascript':
          callback(null, JSON.parse(text), void 0);
          break;
        default:
          callback(null, text, void 0);
      }
      return true;
    };

    DropboxXhr.onError = function(xhr, method, url, callback) {
      var apiError;
      apiError = new DropboxApiError(xhr, method, url);
      callback(apiError);
      return true;
    };

    return DropboxXhr;

  })();

  if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    module.exports = Dropbox;
  } else if (typeof window !== "undefined" && window !== null) {
    window.Dropbox = Dropbox;
  } else {
    throw new Error('This library only supports node.js and modern browsers.');
  }

  Dropbox.ApiError = DropboxApiError;

  Dropbox.Client = DropboxClient;

  Dropbox.CopyReference = DropboxCopyReference;

  Dropbox.Drivers = {
    Popup: DropboxPopupDriver,
    Redirect: DropboxRedirectDriver,
    NodeServer: DropboxNodeServerDriver
  };

  Dropbox.Oauth = DropboxOauth;

  Dropbox.PublicUrl = DropboxPublicUrl;

  Dropbox.PulledChanges = DropboxPulledChanges;

  Dropbox.PullChange = DropboxPullChange;

  Dropbox.Stat = DropboxStat;

  Dropbox.UserInfo = DropboxUserInfo;

  Dropbox.Xhr = DropboxXhr;

  Dropbox.atob = atob;

  Dropbox.btoa = btoa;

  Dropbox.hmac = base64HmacSha1;

  Dropbox.sha1 = base64Sha1;

  Dropbox.encodeKey = dropboxEncodeKey;

}).call(this);
